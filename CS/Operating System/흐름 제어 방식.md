- [[동기]]와 [[비동기]]
- 블로킹과 논블로킹
### **[ 동기 vs 비동기 ]**
- **동기:** 작업이 순차적으로 실행되며, 하나의 작업이 완료될 때까지 다음 작업을 대기
- **비동기:** 작업이 병렬적으로 실행되며, 작업이 완료되지 않아도 다른 작업을 동시에 진행
### **[ 블로킹 vs 논블로킹]**
- **블로킹:** 작업이 완료될 때까지 제어권을 반환하지 않으며, 호출한 쓰레드는 멈춤
- **논블로킹:** 작업이 완료되지 않아도 제어권을 즉시 반환하며, 호출한 쓰레드는 멈추지 않음
### **[ 동기 vs 블로킹 ]**
- **동기 호출은 반드시 블로킹이 아닌 반면에 블로킹 호출은 모두 동기적으로 작동하며 호출한 스레드를 멈춤**
- **동기**: 어떤 함수를 동기 호출했다고 해서 블로킹되거나 스레드가 일시 중지되지 않는다. 결과를 받을 때까지 기다리는 구조이지만, 반드시 호출 스레드를 멈추진 않음
	- 폴링 등 논블로킹 동기 방식 가능
- **블로킹**: 동기 방식이며, 호출한 스레드는 결과를 받을 때까지 일시 중지된다.
### **[ 동기 vs 논블로킹 ]**
- 동기적 요청 중 논블로킹 방식으로 데이터를 조회하거나 처리할 때 사용
### ****[ 비동기 vs 블로킹 ]****
- 이 조합은 일반적으로 사용되지 않으며, 비동기 작업의 본질과 맞지 않음
### **[ 비동기 vs 논블로킹 ]**
- **비동기, 논블로킹**: 네트워크 요청을 보내고 다른 작업하기
	- JavaScript의 `fetch(url).them(...)`
	- Python의 `async def`, `await` 
	- Node.js의 비동기 I/O
- **비동기, 논블로킹** (폴링 방식) : 네트워크 요청을 보내고 특정 주기(10초, 1분, 5분) 확인하면서 다른 작업하기
	- 백엔드 서버에서 비동기 [[Message Queue]] (SQS, Kafka 등) 체크
	- 브라우저에서 일정 시간마다 백엔드 상태 요청 (setInterval + fetch)
- **논블로킹**: 네트워크 요청을 보내고 다른 작업을 할 수 있는데 하지 않고 네트워크 응답이 왔는지만 확인하기
	- 논블로킹 인터페이스를 사용하되 비동기의 이점을 살리지 못한 설계
	- `select()`나 `poll()`을 호출한 뒤 반복해서 결과 확인 (busy-waiting)
	- `socket.recv()`전에 `socket.ready()`로 상태 확인만 반복



https://coor.tistory.com/53