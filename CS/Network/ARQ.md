Automatic Repeat reQuest
자동 재전송 요구, 검출 후 재전송 방식

에러가 발생할 경우 재전송을 요구하는 통신 방식

1. **Stop and Wait**
	수신측으로부터 ACK를 받을 때까지 대기하는 방식
	![[Pasted image 20241022221655.png|450]]
	- 송신 측은 프레임을 보내고 기다림과 동시에 타이머 작동
	    - 수신 측에서는 프레임에 이상이 없으면 ACK 송신
	    - 프레임에 오류가 있으면 NAK 송신
	- 송신 측에서는 ACK를 받으면 타이머 멈춤
	- 오류가 발생한 블록만 재 전송하므로 구현 방법이 가장 단순하고, 신뢰성이 있는 통신 방식
	- 다만, 한 프레임을 보낼 때마다 기다리므로 속도가 느림

2. **Go-back-N ARQ (Continuous ARQ)**
	오류가 난 지점부터 전송한 지점까지 모두 재전송 하는 기법
	![[Pasted image 20241022221911.png|450]] 
	- 한번에 여러 프레임을 보내고, 나중에 ACK를 받는 방식
	- 에러가 발생한 경우, **해당 프레임부터 모두 재전송**
	- 대역폭을 많이 차지하는 단점이 있음
	- Sliding Window 방식이라고도 함

3. **Selective-repeat ARQ**
	![[Pasted image 20241022224222.png|450]] 
	- 한번에 여러 프레임을 보내고, 나중에 ACK를 받는 방식
	- 에러가 발생한 경우, **해당 프레임만 재 전송**
	- 수신자 측은 이미 수신한 프레임을 메모리에 저장해 두고, 나중에 수신 되는 재 전송된 프레임을 포함하여 정렬해야 함. 이때 큰 용량의 버퍼 필요

4. **Adaptive ARQ**
	- 전송 효율을 높이기 위해 블록의 길이를 동적으로 변경 시켜 전송하는 방식
	- 통신 회선의 상태에 따라 블록의 길이를 짧게 하거나 길게 조정 가능

## 연속 재 전송을 하는 두 방식의 비교
| 구분     | Go-back-N              | Selective-repeat    |
| ------ | ---------------------- | ------------------- |
| 에러 발생시 | 손상된 프레임의 이후부터 모두 재전송   | 손상된 프레임만 재전송        |
| 구현 난이도 | 구조가 비교적 간단, 구현 쉬움      | 프레임의 재배열을 구현하기 어려움  |
| 버퍼 유무  | 데이터를 폐기하기 때문에 큰 버퍼 요구X | 프레임 재배치로 인한 큰 버퍼 요구 |